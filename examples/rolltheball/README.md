A atividade consiste no jogo roll the boll. Esse jogo foi inspirado no exemplo do professor Harlen da disciplina de Introdução aos jogos. O jogo consiste de uma bolinha em um espaço delimitado com alguns cubos. O jogador é a bolinha e este tem um tempo delimitado, exibido na tela e que vai decrementando, para pegar todos os cubos. Se conseguir dentro do tempo, ganha, caso o tempo acabe o jogador perde.

Abaixo segue uma visão mais macro do fluxo e funcionamento. Nas próprias funções há comentários mais expecíficos.

Tudo começa na classe Window, tirando a classe Main que é o mesmo padrão usado nos exemplos da disciplina e basicamente gerancia a janela, inicia a apliacação e exibe as exceções. Nessa classe começamos com a função onCreate(), onde carregamos os objetos, carregando seus índices, vértices, VBO, EBO e VAO. Tudo feito através da classe Model, que é a mesma dos exemplos das notas de aulas, porém com algumas modificações para aceitar vários obj e preenche-los ao invés de preencher um objeto associado à classe. Isso foi feito através da passagem de ponteiros nos parâmetros. Criamos as paredes, a bolinha e os cubos. Também chamamos a função restart() para inicializarmos algumas variáveis do jogo, como o estado e tempo passado desde o início. Nessa função chamamos outras duas, a randomizeBox() para sortear a posição, eixo e velocidade de rotação dos cubos, e a checkBoxValidPosition(), onde checamos se a posição do cubo sorteado não esta em conflito com outro. na onCreate() também inicializamos a posição das variáveis uniformes.

Depois da onCreate() temos o onPaint(). Aqui chamos os métodos paint() das classes Ball, Wall, Box e Ground para desenharmos a bolinha, as paredes, os cubos e o chão, respectivamente. Esses médotos paint() basicamente montam as matrizes de translação, rotação e escala, apliacam a cor e chamam o método render() da classe Model, que basicamente desenha de fato o objeto passado.

Em onPaintUI() criamos uma tela auxiliar para exibir os textos de vitórias ou derrota, caso fim do jogo, ou o tempo restante de jogo.

Em onUpdate() começamos chegando se o jogo foi restartado para chamar a função de restart. Obtemos o deltaTime. Chamamos checkWallColision() para saber se a bolinha chegou nos limites do jogo (paredes), caso em que a bolinha não se move e da uma sensação de batida. Depois movimentamos a bolinha de acordo com a seta apertada. Após isso, fazemos a câmera olhar para a bolinha passando a posição desta última como parâmetro para ser usada como o m_at, ponto para onde a câmera olha. Depois atualizamos o angulo dos cubos para os fazerem rodar. Depois checamos se o estado do jogo é diferente de Playing, caso em que saímos da função sem fazer mais nada. Depois disso, incrementamos o tempo de jogo passado, timeElapsed, e checamos se a bolinha "pegou" algum cubo através da função checkBoxColision(). Por fim, checamos os cubos ativos, não colididos, para decidir se o jogador ganhou, ou se o tempo acabou, através do tempo restante, remainedTime, que é calculado usando o tempo máximo e o tempo passado, para dizer se o jogador perdeu.

Na função onEvent() validamos se as setas foram pressionadas ou soltas. Quando apertada, setamos as variáveis verticalSpeed e horizontalSpeed da classe Ball para 1, 0 ou -1 de acordo com a tecla apertada: se direita temos horizontalSpeed valendo 1 e se esquerda -1; se para cima temos verticalSpeed valendo -1 e para baixo temos 1. Isso faz com que consigamos mover a bolinha para todas as direções. Quando soltamos a tecla, checamos se a velocidade está 1 ou -1 para "resetar" (colocar valor 0), para a respectiva velocidade. Também chacamos o clique no enter caso o jogo esteja acabado.